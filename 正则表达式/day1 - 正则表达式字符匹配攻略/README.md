正则表达式是匹配模式，要么匹配字符，要么匹配位置

主要内容： <br />
1、<a href="#first">两种模糊匹配</a> <br />
2、<a href="#second">字符组</a> <br />
3、<a href="#word">量词</a> <br />
4、<a href="#branch">分支结构</a> <br />
5、<a href="#case">案例分析</a>

### <div id="first">一、两种模糊匹配</div>

#### 1.1 横向模糊匹配

横向模糊指的是，一个正则可匹配的字符串的长度不是固定的，可以是多种情况的。
其实现的方式是使用量词。譬如 {m,n}，表示连续出现最少 m 次，最多 n 次。

比如正则 /ab{2,5}c/ 表示匹配这样一个字符串：第一个字符是 "a"，接下来是 2 到 5 个字符 "b"，最后
是字符 "c"。其可视化形式如下

```
const str = "abc abbc abbbc abbbbbc";
console.log( str.match(/ab{2,5}c/g) )

```

#### 1.2 纵向模糊匹配

纵向模糊指的是，一个正则匹配的字符串，具体到某一位字符时，它可以不是某个确定的字符，可以有多种
可能。

其实现的方式是使用字符组。譬如 [abc]，表示该字符是可以字符 "a"、"b"、"c" 中的任何一个。
比如 /a[123]b/ 可以匹配如下三种字符串： "a1b"、"a2b"、"a3b"。

```
const str = "a0b a1b a3b a4b";
console.log( str.match(/a[123]b/g) )
```

### <div id="second">二、字符组</div>

#### 2.1 范围表示法

如果字符组里的字符特别多的话，怎么办？可以使用范围表示法。
比如 `[123456abcdefGHIJKLM]`，可以写成 `[1-6a-fG-M]`。用连字符 - 来省略和简写。

因为连字符有特殊用途，那么要匹配 "a"、"-"、"z" 这三者中任意一个字符，该怎么做呢？
不能写成 `[a-z]`，因为其表示小写字符中的任何一个字符。
可以写成如下的方式：`[-az]` 或 `[az-]` 或 `[a\-z]`。
即要么放在开头，要么放在结尾，要么转义。总之不会让引擎认为是范围表示法就行了。

#### 2.2 排除字符组

纵向模糊匹配，还有一种情形就是，某位字符可以是任何东西，但就不能是 "a"、"b"、"c"。

此时就是排除字符组（反义字符组）的概念。例如 [^abc]，表示是一个除 "a"、"b"、"c"之外的任意一个字
符。字符组的第一位放 ^（脱字符），表示求反的概念。

#### 2.3 常见的简写形式

常见的简写形式

| 字符组 | 具体含义                                                                                                                                                      |
| ------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| \d     | 表示 `[0-9]`。表示是一位数字。                                                                                                                                |
| \D     | 表示 `[^0-9]`。表示除数字外的任意字符                                                                                                                         |
| \w     | 表示 `[0-9a-zA-Z_]`。表示数字、大小写字母和下划线 <br /> 记忆方式：w 是 word 的简写，也称单词字符。                                                           |
| \W     | 表示 `[^0-9a-zA-Z_]`。非单词字符                                                                                                                              |
| \s     | 表示 `[ \t\v\n\r\f]`。表示空白符，包括空格、水平制表符、垂直制表符、换行符、回车符、换页符 <br /> 记忆方式：s 是 space 的首字母，空白符的单词是 white space。 |
| \S     | 表示 `[^ \t\v\n\r\f]`。 非空白符                                                                                                                              |

### <div id="word">三、量词</div>

量词也称重复。掌握 {m,n} 的准确含义后，只需要记住一些简写形式

#### 1.1 简写形式

| 量词 | 具体含义                                  |
| ---- | ----------------------------------------- |
| {m,} | 表示至少出现 m 次。                       |
| {m}  | 等价于 {m,m}，表示出现 m 次。             |
| ?    | 等价于 {0,1}，表示出现或者不出现          |
| +    | 等价于 {1,}，表示出现至少一次             |
| \*   | 等价于 {0,}，表示出现任意次，有可能不出现 |

#### 1.2 贪婪匹配和惰性匹配

- 贪婪匹配

```
var regex = /\d{2,5}/g;
var string = "123 1234 12345 123456";
console.log( string.match(regex) );
// => ["123", "1234", "12345", "12345"]
```

你能给我 6 个，我就要 5 个。你能给我 3 个，我就要 3 个。
反正只要在能力范围内，越多越好

- 惰性匹配

```
var regex = /\d{2,5}?/g;
var string = "123 1234 12345 123456";
console.log( string.match(regex) );
// => ["12", "12", "34", "12", "34", "12", "34", "56"]
```

其中 /\d{2,5}?/ 表示，虽然 2 到 5 次都行，当 2 个就够的时候，就不再往下尝试了。

通过在量词后面加个问号就能实现惰性匹配，因此所有惰性匹配情形如下：

| 惰性量词 | 贪婪量词 |
| -------- | -------- |
| {m,n}?   | {m,n}    |
| {m,}?    | {m,}     |
| ??       | ?        |
| +?       | +        |
| \*?      | \*       |

### <div id="branch">四、分支结构</div>

一个模式可以实现横向和纵向模糊匹配。而多选分支可以支持多个子模式任选其一。

具体形式如下：(p1|p2|p3)，其中 p1、p2 和 p3 是子模式，用 |（管道符）分隔，表示其中任何之一。

例如要匹配字符串 "good" 和 "nice" 可以使用 /good|nice/。

```
var regex = /good|nice/g;
var string = "good idea, nice try.";
console.log( string.match(regex) );
// => ["good", "nice"]
```

但有个事实我们应该注意，比如我用 /good|goodbye/，去匹配 "goodbye" 字符串时，结果是 "good"：

```
var regex = /good|goodbye/g;
var string = "goodbye";
console.log( string.match(regex) );
// => ["good"]
```

而把正则改成 /goodbye|good/，结果是

```
var regex = /goodbye|good/g;
var string = "goodbye";
console.log( string.match(regex) );
// => ["goodbye"]
```

也就是说，分支结构也是惰性的，即当前面的匹配上了，后面的就不再尝试了。

### <div id="case">五、案例分析</div>

#### 匹配16进制颜色

分析：

- 表示一个 16 进制字符，可以用字符组 [0-9a-fA-F]。
- 其中字符可以出现 3 或 6 次，需要是用量词和分支结构。
- 使用分支结构时，需要注意顺序

```
const regex = /#([0-9a-fA-F]{6}|[0-9a-fA-F]{3})/g;
var string = "#ffbbad #Fc01DF #FFF #ffE";
console.log( string.match(regex) );
```

#### 匹配时间

分析：

- 第一位数字 [0-2]。
- 第二位数字 [0-9]。当第 1 位为 "2" 时，第 2 位可以为 [0-3]，其他情况时，第 2 位为 [0-9]。
- 第三位数字 [0-5]。
- 第四位数字 [0-9]。

```
const regex = /^([01][0-9]|[2][0-3]):[0-5][0-9]$/;
console.log( regex.test("23:59") );
console.log( regex.test("02:07") );
// => true
// => true
```

#### 匹配日期

形式 YYYY-MM--DD

- 年 `[0-9]`
- 月 `[0][1-9]|[1][0-2]`
- 日 (`0[1-9]|[12][0-9]|3[01]`)

```
var regex = /^[0-9]{4}-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])$/;
console.log( regex.test("2017-06-10") );
// => true
```
